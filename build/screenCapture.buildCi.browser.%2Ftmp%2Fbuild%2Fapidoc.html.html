<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a>smtp-server (v3.0.1)</a>
</h1>
<h4>Create custom SMTP servers on the fly</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.smtp-server">module smtp-server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.SMTPServer">
            function <span class="apidocSignatureSpan">smtp-server.</span>SMTPServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">smtp-server.</span>sasl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">smtp-server.</span>smtp_connection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">smtp-server.</span>smtp_stream</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.smtp-server.sasl">module smtp-server.sasl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.CRAM-MD5_token">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>CRAM-MD5_token
            <span class="apidocSignatureSpan">(canAbort, challenge, token, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.LOGIN_password">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>LOGIN_password
            <span class="apidocSignatureSpan">(username, password, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.LOGIN_username">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>LOGIN_username
            <span class="apidocSignatureSpan">(canAbort, username, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.PLAIN_token">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>PLAIN_token
            <span class="apidocSignatureSpan">(canAbort, token, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.SASL_CRAM-MD5">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_CRAM-MD5
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.SASL_LOGIN">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_LOGIN
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.SASL_PLAIN">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_PLAIN
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.SASL_XOAUTH2">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_XOAUTH2
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.XOAUTH2_error">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>XOAUTH2_error
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.sasl.XOAUTH2_token">
            function <span class="apidocSignatureSpan">smtp-server.sasl.</span>XOAUTH2_token
            <span class="apidocSignatureSpan">(canAbort, token, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.smtp-server.smtp_connection">module smtp-server.smtp_connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.smtp_connection.SMTPConnection">
            function <span class="apidocSignatureSpan">smtp-server.smtp_connection.</span>SMTPConnection
            <span class="apidocSignatureSpan">(server, socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.smtp-server.smtp_stream">module smtp-server.smtp_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.smtp-server.smtp_stream.SMTPStream">
            function <span class="apidocSignatureSpan">smtp-server.smtp_stream.</span>SMTPStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.smtp-server" id="apidoc.module.smtp-server">module smtp-server</a></h1>


    <h2>
        <a href="#apidoc.element.smtp-server.SMTPServer" id="apidoc.element.smtp-server.SMTPServer">
        function <span class="apidocSignatureSpan">smtp-server.</span>SMTPServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SMTPServer extends EventEmitter {
    constructor(options) {
        super();

        this.options = options || {};

        this.secureContext = new Map();
        this.secureContext.set('default', tls.createSecureContext(tlsOptions(this.options)));

        let ctxMap = this.options.sniOptions || {};
        if (typeof ctxMap.get === 'function') {
            ctxMap.forEach((ctx, servername) =&gt; {
                this.secureContext.set(servername.toLowerCase().trim(), tls.createSecureContext(tlsOptions(ctx)));
            });
        } else {
            Object.keys(ctxMap).forEach(servername =&gt; {
                this.secureContext.set(servername.toLowerCase().trim(), tls.createSecureContext(tlsOptions(ctxMap[servername])));
            });
        }

        // apply TLS defaults if needed, only if there is not SNICallback.
        if (this.options.secure &amp;&amp; typeof this.options.SNICallback !== 'function') {
            this.options = tlsOptions(this.options);
            this.options.SNICallback = (servername, cb) =&gt; {
                cb(null, this.secureContext.get(servername.toLowerCase().trim()) || this.secureContext.get('default'));
            };
        }

        // setup disabled commands list
        this.options.disabledCommands = [].concat(this.options.disabledCommands || [])
            .map(command =&gt; (command || '').toString().toUpperCase().trim());

        // setup allowed auth methods
        this.options.authMethods = [].concat(this.options.authMethods || [])
            .map(method =&gt; (method || '').toString().toUpperCase().trim());

        if (!this.options.authMethods.length) {
            this.options.authMethods = ['LOGIN', 'PLAIN'];
        }

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'smtp-server'
        });

        // apply shorthand handlers
        ['onConnect', 'onAuth', 'onMailFrom', 'onRcptTo', 'onData', 'onClose'].forEach(handler =&gt; {
            if (typeof this.options[handler] === 'function') {
                this[handler] = this.options[handler];
            }
        });

<span class="apidocCodeCommentSpan">        /**
         * Timeout after close has been called until pending connections are forcibly closed
         */
</span>        this._closeTimeout = false;

        /**
         * A set of all currently open connections
         */
        this.connections = new Set();

        // setup server listener and connection handler
        this.server = (this.options.secure ? tls : net)
            .createServer(this.options, socket =&gt; this.connect(socket));

        // ensure _sharedCreds, fixes an issue in node v4+ where STARTTLS fails because _sharedCreds does not exist
        this.server._sharedCreds = this.server._sharedCreds || this.secureContext.get('default');

        this._setListeners();
    }

    connect(socket) {
        let connection = new SMTPConnection(this, socket);
        this.connections.add(connection);
        connection.on('error', err =&gt; this._onError(err));
        connection.on('connect', data =&gt; this._onClientConnect(data));
        connection.init();
    }

    /**
     * Start listening on selected port and interface
     */
    listen(...args) {
        this.server.listen(...args);
    }

    /**
     * Closes the server
     *
     * @param {Function} callback Callback to run once the server is fully closed
     */
    close(callback) {
        let connections = this.connections.size;
        let timeout = this.options.closeTimeout || CLOSE_TIMEOUT;

        // stop accepting new connections
        this.server.close(() =&gt; {
            clearTimeout(this._closeTimeout);
            if (typeof callback === 'function') {
                return callback();
            }
        });

        // close active connections
        if (connections) {
            this.logger.info({
                tnx: 'close'
            }, 'Server closing with %s pending connection%s, waiting %s seconds before terminating', connections, connections !==
1 ? 's' : '', timeout / 1000);
        }

        this._closeTimeout = setTimeout(() =&gt; { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.smtp-server.sasl" id="apidoc.module.smtp-server.sasl">module smtp-server.sasl</a></h1>


    <h2>
        <a href="#apidoc.element.smtp-server.sasl.CRAM-MD5_token" id="apidoc.element.smtp-server.sasl.CRAM-MD5_token">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>CRAM-MD5_token
        <span class="apidocSignatureSpan">(canAbort, challenge, token, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CRAM-MD5_token(canAbort, challenge, token, callback) {
    token = (token || '').toString().trim();

    if (canAbort &amp;&amp; token === '*') {
        this.send(501, 'Authentication aborted');
        return callback();
    }

    let tokenParts = new Buffer(token, 'base64').toString().split(' ');
    let username = tokenParts.shift();
    let challengeResponse = (tokenParts.shift() || '').toLowerCase();

    this._server.onAuth({
        method: 'CRAM-MD5',
        username,
        validatePassword(password) {
            let hmac = crypto.createHmac('md5', password);
            return hmac.update(challenge).digest('hex').toLowerCase() === challengeResponse;
        }
    }, this.session, (err, response) =&gt; {

        if (err) {
            this._server.logger.info({
                err,
                tnx: 'autherror',
                cid: this._id,
                method: 'CRAM-MD5',
                user: username
            }, 'Authentication error for %s using %s. %s', username, 'CRAM-MD5', err.message);
            this.send(err.responseCode || 535, err.message);
            return callback();
        }

        if (!response.user) {
            this._server.logger.info({
                tnx: 'authfail',
                cid: this._id,
                method: 'CRAM-MD5',
                user: username
            }, 'Authentication failed for %s using %s', username, 'CRAM-MD5');
            this.send(response.responseCode || 535, response.message || 'Error: Authentication credentials invalid');
            return callback();
        }

        this._server.logger.info({
            tnx: 'auth',
            cid: this._id,
            method: 'CRAM-MD5',
            user: username
        }, '%s authenticated using %s', username, 'CRAM-MD5');
        this.session.user = response.user;
        this.session.transmissionType = this._transmissionType();

        this.send(235, 'Authentication successful');
        callback();

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.LOGIN_password" id="apidoc.element.smtp-server.sasl.LOGIN_password">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>LOGIN_password
        <span class="apidocSignatureSpan">(username, password, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LOGIN_password(username, password, callback) {
    password = (password || '').toString().trim();

    if (password === '*') {
        this.send(501, 'Authentication aborted');
        return callback();
    }

    password = new Buffer(password, 'base64').toString();

    this._server.onAuth({
        method: 'LOGIN',
        username,
        password
    }, this.session, (err, response) =&gt; {

        if (err) {
            this._server.logger.info({
                err,
                tnx: 'autherror',
                cid: this._id,
                method: 'LOGIN',
                user: username
            }, 'Authentication error for %s using %s. %s', username, 'LOGIN', err.message);
            this.send(err.responseCode || 535, err.message);
            return callback();
        }

        if (!response.user) {
            this._server.logger.info({
                tnx: 'authfail',
                cid: this._id,
                method: 'LOGIN',
                user: username
            }, 'Authentication failed for %s using %s', username, 'LOGIN');
            this.send(response.responseCode || 535, response.message || 'Error: Authentication credentials invalid');
            return callback();
        }

        this._server.logger.info({
            tnx: 'auth',
            cid: this._id,
            method: 'PLAIN',
            user: username
        }, '%s authenticated using %s', username, 'LOGIN');
        this.session.user = response.user;
        this.session.transmissionType = this._transmissionType();

        this.send(235, 'Authentication successful');
        callback();

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.LOGIN_username" id="apidoc.element.smtp-server.sasl.LOGIN_username">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>LOGIN_username
        <span class="apidocSignatureSpan">(canAbort, username, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LOGIN_username(canAbort, username, callback) {
    username = (username || '').toString().trim();

    if (canAbort &amp;&amp; username === '*') {
        this.send(501, 'Authentication aborted');
        return callback();
    }

    username = new Buffer(username, 'base64').toString();

    if (!username) {
        this.send(500, 'Error: missing username');
        return callback();
    }

    this._nextHandler = SASL.LOGIN_password.bind(this, username);
    this.send(334, 'UGFzc3dvcmQ6');
    return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.PLAIN_token" id="apidoc.element.smtp-server.sasl.PLAIN_token">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>PLAIN_token
        <span class="apidocSignatureSpan">(canAbort, token, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PLAIN_token(canAbort, token, callback) {
    token = (token || '').toString().trim();

    if (canAbort &amp;&amp; token === '*') {
        this.send(501, 'Authentication aborted');
        return callback();
    }

    let data = new Buffer(token, 'base64').toString().split('\x00');

    if (data.length !== 3) {
        this.send(500, 'Error: invalid userdata');
        return callback();
    }

    let username = data[1] || data[0] || '';
    let password = data[2] || '';

    this._server.onAuth({
        method: 'PLAIN',
        username,
        password
    }, this.session, (err, response) =&gt; {

        if (err) {
            this._server.logger.info({
                err,
                tnx: 'autherror',
                cid: this._id,
                method: 'PLAIN',
                user: username
            }, 'Authentication error for %s using %s. %s', username, 'PLAIN', err.message);
            this.send(err.responseCode || 535, err.message);
            return callback();
        }

        if (!response.user) {
            this._server.logger.info({
                tnx: 'authfail',
                cid: this._id,
                method: 'PLAIN',
                user: username
            }, 'Authentication failed for %s using %s', username, 'PLAIN');
            this.send(response.responseCode || 535, response.message || 'Error: Authentication credentials invalid');
            return callback();
        }

        this._server.logger.info({
            tnx: 'auth',
            cid: this._id,
            method: 'PLAIN',
            user: username
        }, '%s authenticated using %s', username, 'PLAIN');
        this.session.user = response.user;
        this.session.transmissionType = this._transmissionType();

        this.send(235, 'Authentication successful');
        callback();

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.SASL_CRAM-MD5" id="apidoc.element.smtp-server.sasl.SASL_CRAM-MD5">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_CRAM-MD5
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SASL_CRAM-MD5(args, callback) {
    if (args.length) {
        this.send(501, 'Error: syntax: AUTH CRAM-MD5');
        return callback();
    }

    let challenge = util.format('&lt;%s%s@%s&gt;',
        String(Math.random()).replace(/^[0\.]+/, '').substr(0, 8), // random numbers
        Math.floor(Date.now() / 1000), // timestamp
        this.name // hostname
    );

    this._nextHandler = SASL['CRAM-MD5_token'].bind(this, true, challenge);
    this.send(334, new Buffer(challenge).toString('base64'));
    return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.SASL_LOGIN" id="apidoc.element.smtp-server.sasl.SASL_LOGIN">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_LOGIN
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SASL_LOGIN(args, callback) {
    if (args.length &gt; 1) {
        this.send(501, 'Error: syntax: AUTH LOGIN');
        return callback();
    }

    if (!args.length) {
        this._nextHandler = SASL.LOGIN_username.bind(this, true);
        this.send(334, 'VXNlcm5hbWU6');
        return callback();
    }

    SASL.LOGIN_username.call(this, false, args[0], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.SASL_PLAIN" id="apidoc.element.smtp-server.sasl.SASL_PLAIN">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_PLAIN
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SASL_PLAIN(args, callback) {
    if (args.length &gt; 1) {
        this.send(501, 'Error: syntax: AUTH PLAIN token');
        return callback();
    }

    if (!args.length) {
        this._nextHandler = SASL.PLAIN_token.bind(this, true);
        this.send(334);
        return callback();
    }

    SASL.PLAIN_token.call(this, false, args[0], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.SASL_XOAUTH2" id="apidoc.element.smtp-server.sasl.SASL_XOAUTH2">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>SASL_XOAUTH2
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SASL_XOAUTH2(args, callback) {
    if (args.length &gt; 1) {
        this.send(501, 'Error: syntax: AUTH XOAUTH2 token');
        return callback();
    }

    if (!args.length) {
        this._nextHandler = SASL.XOAUTH2_token.bind(this, true);
        this.send(334);
        return callback();
    }

    SASL.XOAUTH2_token.call(this, false, args[0], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.XOAUTH2_error" id="apidoc.element.smtp-server.sasl.XOAUTH2_error">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>XOAUTH2_error
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">XOAUTH2_error(data, callback) {
    this.send(535, 'Error: Username and Password not accepted');
    return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.smtp-server.sasl.XOAUTH2_token" id="apidoc.element.smtp-server.sasl.XOAUTH2_token">
        function <span class="apidocSignatureSpan">smtp-server.sasl.</span>XOAUTH2_token
        <span class="apidocSignatureSpan">(canAbort, token, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">XOAUTH2_token(canAbort, token, callback) {
    token = (token || '').toString().trim();

    if (canAbort &amp;&amp; token === '*') {
        this.send(501, 'Authentication aborted');
        return callback();
    }

    let username;
    let accessToken;

    // Find username and access token from the input
    new Buffer(token, 'base64').toString().split('\x01').forEach(part =&gt; {
        part = part.split('=');
        let key = part.shift().toLowerCase();
        let value = part.join('=').trim();

        if (key === 'user') {
            username = value;
        } else if (key === 'auth') {
            value = value.split(/\s+/);
            if (value.shift().toLowerCase() === 'bearer') {
                accessToken = value.join(' ');
            }
        }
    });

    if (!username || !accessToken) {
        this.send(500, 'Error: invalid userdata');
        return callback();
    }

    this._server.onAuth({
        method: 'XOAUTH2',
        username,
        accessToken
    }, this.session, (err, response) =&gt; {

        if (err) {
            this._server.logger.info({
                err,
                tnx: 'autherror',
                cid: this._id,
                method: 'XOAUTH2',
                user: username
            }, 'Authentication error for %s using %s. %s', username, 'XOAUTH2', err.message);
            this.send(err.responseCode || 535, err.message);
            return callback();
        }

        if (!response.user) {
            this._server.logger.info({
                tnx: 'authfail',
                cid: this._id,
                method: 'XOAUTH2',
                user: username
            }, 'Authentication failed for %s using %s', username, 'XOAUTH2');
            this._nextHandler = SASL.XOAUTH2_error.bind(this);
            this.send(response.responseCode || 334, new Buffer(JSON.stringify(response.data || {})).toString('base64'));
            return callback();
        }

        this._server.logger.info({
            tnx: 'auth',
            cid: this._id,
            method: 'XOAUTH2',
            user: username
        }, '%s authenticated using %s', username, 'XOAUTH2');
        this.session.user = response.user;
        this.session.transmissionType = this._transmissionType();

        this.send(235, 'Authentication successful');
        callback();

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.smtp-server.smtp_connection" id="apidoc.module.smtp-server.smtp_connection">module smtp-server.smtp_connection</a></h1>


    <h2>
        <a href="#apidoc.element.smtp-server.smtp_connection.SMTPConnection" id="apidoc.element.smtp-server.smtp_connection.SMTPConnection">
        function <span class="apidocSignatureSpan">smtp-server.smtp_connection.</span>SMTPConnection
        <span class="apidocSignatureSpan">(server, socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SMTPConnection extends EventEmitter {
    constructor(server, socket) {
        super();
        // Random session ID, used for logging
        this._id = crypto.randomBytes(9).toString('base64');

        this._server = server;
        this._socket = socket;

        // session data (envelope, user etc.)
        this.session = this.session = {
            id: this._id
        };

        // how many messages have been processed
        this._transactionCounter = 0;

        // Do not allow input from client until initial greeting has been sent
        this._ready = false;

        // If true then the connection is currently being upgraded to TLS
        this._upgrading = false;

        // Set handler for incoming command and handler bypass detection by command name
        this._nextHandler = false;

        // Parser instance for the incoming stream
        this._parser = new SMTPStream();

        // Set handler for incoming commands
        this._parser.oncommand = (...args) =&gt; this._onCommand(...args);

        // if currently in data mode, this stream gets the content of incoming message
        this._dataStream = false;

        // If true, then the connection is using TLS
        this.session.secure = this.secure = !!this._server.options.secure;

        this.tlsOptions = this.secure ? this._socket.getCipher() : false;

        // Store remote address for later usage
        this.remoteAddress = (this._socket.remoteAddress || '').replace(/^::ffff:/, '');
        this.remotePort = Number(this._socket.remotePort) || 0;

        // normalize IPv6 addresses
        if (this.remoteAddress &amp;&amp; net.isIPv6(this.remoteAddress)) {
            this.remoteAddress = ipv6normalize(this.remoteAddress);
        }

        // Error counter - if too many commands in non-authenticated state are used, then disconnect
        this._unauthenticatedCommands = 0;

        // Error counter - if too many invalid commands are used, then disconnect
        this._unrecognizedCommands = 0;

        // Server hostname for the greegins
        this.name = this._server.options.name || os.hostname();

        // Resolved hostname for remote IP address
        this.clientHostname = false;

        // The opening SMTP command (HELO, EHLO or LHLO)
        this.openingCommand = false;

        // The hostname client identifies itself with
        this.hostNameAppearsAs = false;

        // data passed from XCLIENT command
        this._xClient = new Map();

        // data passed from XFORWARD command
        this._xForward = new Map();

        // if true then can emit connection info
        this._canEmitConnection = true;

        // increment connection count
        this._closing = false;
        this._closed = false;
    }

<span class="apidocCodeCommentSpan">    /**
     * Initiates the connection. Checks connection limits and reverse resolves client hostname. The client
     * is not allowed to send anything before init has finished otherwise 'You talk too soon' error is returned
     */
</span>    init() {
        // Setup event handlers for the socket
        this._setListeners();

        // Check that connection limit is not exceeded
        if (this._server.options.maxClients &amp;&amp; this._server.connections.size &gt; this._server.options.maxClients) {
            return this.send(421, this.name + ' Too many connected clients, try again in a moment');
        }

        if (!this._server.options.useProxy) {
            // Keep a small delay for detecting early talkers
            setTimeout(() =&gt; this.connectionReady(), 100);
        }
    }

    connectionReady(next) {

        // Resolve hostname for the remote IP
        let reverseCb = (err, hostnames) =&gt; {
            if (err) {
                // ignore resolve error
            }

            if (this._closing || this._closed) {
                return;
            }

            this.clientHostname = hostnames &amp;&amp; hostnames.shift() || '[' + this.remoteAddress + ']';

            this._resetSession();

            this._server.onConnect(this.session, err =&gt; {
                this._server.logger.info({
                    tnx: ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.smtp-server.smtp_stream" id="apidoc.module.smtp-server.smtp_stream">module smtp-server.smtp_stream</a></h1>


    <h2>
        <a href="#apidoc.element.smtp-server.smtp_stream.SMTPStream" id="apidoc.element.smtp-server.smtp_stream.SMTPStream">
        function <span class="apidocSignatureSpan">smtp-server.smtp_stream.</span>SMTPStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SMTPStream extends Writable {
    constructor(options) {
        // init Writable
        super(options);

        // Indicates if the stream is currently in data mode
        this._dataMode = false;
        // Output stream for the current data mode
        this._dataStream = null;
        // How many bytes are allowed for a data stream
        this._maxBytes = Infinity;
        // How many bytes have been emitted to data stream
        this.dataBytes = 0;
        // Callback to run once data mode is finished
        this._continueCallback = false;
        // unprocessed chars from the last parsing iteration (used in command mode)
        this._remainder = '';
        // unprocessed bytes from the last parsing iteration (used in data mode)
        this._lastBytes = false;

        this.closed = false;
        // once the input stream ends, flush all output without expecting the newline
        this.on('finish', () =&gt; this._flushData());
    }

<span class="apidocCodeCommentSpan">    /**
     * Placeholder command handler. Override this with your own.
     */
</span>    oncommand( /* command, callback */ ) {
        throw new Error('Command handler is not set');
    }

    /**
     * Switch to data mode and return output stream. The dots in the stream are unescaped.
     *
     * @returns {Stream} Data stream
     */
    startDataMode(maxBytes) {
        this._dataMode = true;
        this._maxBytes = maxBytes &amp;&amp; Number(maxBytes) || Infinity;
        this.dataBytes = 0;
        this._dataStream = new PassThrough();

        return this._dataStream;
    }

    /**
     * Call this once data mode is over and you have finished processing the data stream
     */
    continue () {
        if (typeof this._continueCallback === 'function') {
            this._continueCallback();
            this._continueCallback = false;
        } else {
            // indicate that the 'continue' was already called once the stream actually ends
            this._continueCallback = true;
        }
    }

    // PRIVATE METHODS

    /**
     * Writable._write method.
     */
    _write(chunk, encoding, next) {
        if (!chunk || !chunk.length) {
            return next();
        }

        let data;
        let pos = 0;
        let newlineRegex;

        let called = false;
        let done = (...args) =&gt; {
            if (called) {
                return;
            }
            called = true;
            next(...args);
        };

        if (this.closed) {
            return done();
        }

        if (!this._dataMode) {

            newlineRegex = /\r?\n/g;
            data = this._remainder + chunk.toString('binary');

            let readLine = () =&gt; {
                let match;
                let line;
                let buf;

                // check if the mode is not changed
                if (this._dataMode) {
                    buf = new Buffer(data.substr(pos), 'binary');
                    this._remainder = '';
                    return this._write(buf, 'buffer', done);
                }

                // search for the next newline
                // exec keeps count of the last match with lastIndex
                // so it knows from where to start with the next iteration
                if ((match = newlineRegex.exec(data))) {
                    line = data.substr(pos, match.index - pos);
                    pos += line.length + match[0].length;
                } else {
                    this._remainder = pos &lt; data.length ? data.substr(pos) : '';
                    return done();
                }

                this.oncommand(new Buffer(line, 'binary'), readLine);
            };

            // start reading lines
            readLine();

        } else {
            this._feedDataStream(chunk, done);
        }
    }

    /**
     * Processes a chunk in data mode. Escape dots are removed and final dot ends the data mode.
     */
    _feedDataStream(chunk, done) {
        let i;
        let endseq = new Buffer('\r\n.\r\n');
        let len;
        let handled;
        let buf;

        if (this._lastBytes &amp;&amp; this._lastBytes.length) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>